\documentclass[thesis]{subfiles}

\begin{document}

\OnlyInSubfile{\appendix}
\chapter{Chemfiles: library for chemistry Input/Output}
\label{sec:chemfiles}

During my PhD, I also wrote chemfiles, a library that allow to read and write
multiple file formats used in computational chemistry. I will present here the
software, its goals and some software architecture choices I made to reach these
goals.

\vfill
\begin{figure}[H]
    \centering
    \includegraphics[width=.3\textwidth]{figures/images/chemfiles-logo}
    \caption{Chemfiles' project logo}
    \label{fig:chemfiles:logo}
\end{figure}
\vfill

\newpage
\section{The computational chemistry formats zoo}

A recurrent pain point for anyone working in the theoretical and computational
chemistry field is the multiplication of file formats. Every simulation software
comes with its own set of files formats. And it is up to the user to adapt, and
learn how to work with the set of formats used by a specific software. These
formats are used to store data generated by a simulation software, before
analyzing it either through visualization of the atoms and their individual
motions; or by computing properties of the system from the positions and
velocities, using the framework of statistical thermodynamics presented in
section~\ref{sec:statistical-thermo}.

At the same time, every format contains the same kind of information: atomic
names, positions, velocities, forces, and topological information (bonds,
residues, \etc). Different formats exist because in addition to storing this
basic data, they have different use cases. For example, the XYZ format is very
simple to read an write, both by hand and when creating new softwares. Binary
formats, such as NetCDF or TNG allow to store huge trajectories efficiently,
both in term of disk size and reading speed. The PBD, mmCIF and MMTF format are
optimized to store proteins and other bio-molecules.

\begin{figure}[ht]
    \centering
    \includegraphics[width=.4\textwidth]{figures/images/files-formats}
    \caption{Some of the existing formats used in computational chemistry.}
    \label{fig:chemfiles:formats}
\end{figure}

This multiplication of formats means that there is less interoperability between
different software. Analysis and visualization software support specific

To run analysis on the results of a simulation wee have to
either use readily available algorithms, or learn how to read the format of our
current software. There is quite a lot of friction to switch between simulation
softwares or to use a specific analysis code

Chemfiles is an attempt to provide an unified and simple interface for
programmers to work with all these file formats. In order to do so, it defines a
representation for the data that can exist in various formats, and transparently
reads and writes files from and to this representation. Which means that
software developers only need to learn how to use chemfiles, and can then use it
to read or write every supported file format!

Chemfiles is a software library; a collection of functions and classes meant to
be integrated into other software. It can be used in simulation software (for
example Domino uses chemfiles for reading the initial configuration and writing
the trajectory); visualization or analysis software, such as cfiles, presented
below.

\section{An overview of chemfiles}

\subsection{Goals and non-goals}

The main goal of chemfiles is to be useful to the research community at large.
To be useful, chemfiles must first be usable, and different researchers and
softwares developers work with different computing environments. Chemfiles is
portable between different platforms, operating systems (Windows, GNU/Linux,
macOS), word sizes (32 or 64-bits environments) and CPU architecture (Intel,
ARM, PowerPC, \dots). It is also usable from multiple language, to allow any
computation chemistry project to use it, regardless of the implementation
language the authors choose. The core of the library is written in \cxx, and it
offers interfaces to C, Python, Fortran, Julia and Rust.

Computational chemistry is used with a wide range of systems, and each kind of
system has specific requirements, which chemfiles tries to support. For
example, simulations of bio-molecules such as proteins or nucleic acid strands
uses complex topologies, grouping some atoms in residues or monomers.
Oftentimes, this topology is stored in a separated file. While bio-molecules
simulation mostly only needs orthorhombic unit cells, material science and
crystallographic data needs to describe triclinic unit cells, where some of the
angles are not 90°. Finally, when working with simulations in the grand
canonical ensemble such as GCMC, the number of atoms in the system changes along
the trajectory. Support for such simulations where the number of atoms is not
constant is often missing from existing software.

Chemfiles also has explicit non-goals: features that should not be part of
chemfiles itself, but could instead be built on the top of it. For example,
trajectory analysis, energy minimization or simulation algorithms would add to
much complexity to the code. Chemfiles is also actively trying \textbf{not} to
create a new format. Instead, it focuses on providing interoperability between
existing formats.

\subsection{Existing alternatives}

Multiple attempts to solve the issue of file format multiplication already
exist. Here, I will review some of these, and compare them to chemfiles,
given the goals stated above for this kind of library.

\subsubsection{OpenBabel}

OpenBabel\cite{OBoyle2011} is \cxx library that provides read and write
capabilities to other softwares. It is a well established software supporting
more than 110 different file formats. Unfortunately, it only support text/ASCII
based formats, and no binary formats such as Amber NetCDF or Gromacs TNG. Such
binary formats are used to store big trajectories, are faster and take less
space than equivalent text formats.

Two other caveats of OpenBabel for me were the complexity of the programming
interface, and its license. OpenBabel is distributed under the Gnu Public
License version 2 (GPL-v2), which requires any project using it to be released
under the same license. This is due to the project's history, which was created
from the OELib project, itself distributed under the GPL license. This
requirement makes it harder to use OpenBabel in projects which uses another
license, either another open source license or proprietary software developed by
a private company.

Concerning the programming interface, OpenBabel is written with the \cxx 98
standard, and a lot of member functions return raw pointers to internal data
directly, instead of the more modern references or smart pointers introduced
with \cxx11. This type of interface means that the programmer using the library
needs to manage memory manually, which in turn introduces more memory bugs in
the applications. Furthermore, I find the overall interface to be complex and
hard to learn, with many different functionalities not directly related to file
reading and writing. For example, it contains functions to search low energy
conformers, to create graphical images of molecules or to manage chemical
reactions. All of these functionalities are useful for cheminformatics
applications, but can clutter other uses of OpenBabel.

\subsubsection{Other alternatives}

\begin{table}[ht]
    \centering
    \caption{Summary of existing popular software library providing read/write
    capabilities for chemistry file formats.}
    \label{tab:chemfiles:alternatives}
    \def\nope{\textcolor{red}{✗}}
    \def\yep{\textcolor{webgreen}{✓}}
    \begin{tabularx}{0.8\textwidth}{X c c c c}
        \toprule
        \bfseries Project            & language & \cxx compatible & GCMC  & license \\
        \midrule
        OpenBabel\cite{OBoyle2011}   &   \cxx   &      \yep       & \nope & GPL-2   \\
        VMD\cite{Humphrey1996}       &  C/\cxx  &      \yep       & \nope & BSD     \\
        MDAnalysis\cite{Michaud2011} &  Python  &      \nope      & \nope & GPL-2   \\
        cclib\cite{OBoyle2008}       &  Python  &      \nope      & \nope & BSD     \\
        ASE\cite{HjorthLarsen2017}   &  Python  &      \nope      & \nope & LGPL    \\
        CDK\cite{Willighagen2017}    &  Java    &      \nope      & \nope & LGPL    \\
        \bottomrule
    \end{tabularx}
\end{table}

Multiple other alternatives to OpenBabel also exists, with different set of
goals and implementations; I summarize the most popular ones in
table~\ref{tab:chemfiles:alternatives}. Unfortunately, none of these
alternatives support GCMC simulations, with a number of molecules which can vary
during the simulation. Other than OpenBabel, only VMD molfile plugins (written
in C and \cxx) are compatible with \cxx simulation software. Most of the other
are written in Python, with the notable exception of the Chemical Development
Kit (CDK), written in Java.

I could not find an existing library that would cover all of my needs, which is
why I started working on chemfiles. I hope to increase the number of options
available to developers of chemical scientific software, and provide tools for
users of these software improving interoperability.

\subsection{Some code statistics}

I started working on chemfiles in December 2014, and released the 0.1 version
the 16th of May 2015. Since then, I released 8 new versions, the last one being
version 0.9, which was released on the 31 of March 2019. During this period,
they have been 1500 git commits (self-contained modifications) in the core \cxx
chemfiles library, leading to a library containing 23 000 lines of code, as well
as 11 000 lines of test code. Bindings to chemfiles in other languages (Python,
Fortran, Rust, Julia) collectively contains 800 commits, 12 000 lines of code,
and 5 000 lines of tests.

A few people helped me making chemfiles what it is today, I would like to thank
them all here again: Jonathan Fine from Purdue University (USA); Patricio Germán
Barletta from Universidad Nacional de Quilmes (Argentina); Laura Scalfi and Elsa
Perrin from École Normale Supérieure (France).

\section{Architecture and functionalities}

In this section, I will describe the general architecture of chemfiles, and then
dive into some specific features which I believe to be interesting in this
context. In particular, I will describe how one can store additional metadata in
a statically compiled language; the implementation and specificities of chemfiles'
atomic selection language; and how to use a software library from multiple
different programming languages.

\subsection{Public classes}

The full interface to chemfiles is contained into eight public classes, which
are represented in figure~\ref{fig:chemfiles:classes}. The starting point is the
\texttt{Trajectory} class, which provides functions to read or write a
\texttt{Frame}, as well as managing metadata associated with the trajectory. The
\texttt{Trajectory} does not do the actual work of parsing and formatting data,
which is delegated to the \texttt{Format} classes, presented in
section~\ref{sec:chemfiles:formats}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/images/chemfiles-classes}
    \caption{Relation between chemfiles' public classes.}
    \label{fig:chemfiles:classes}
\end{figure}

The \texttt{Frame} class is the central class of chemfiles, it stores all the
data associated with a simulation step: positions, velocities, \texttt{UnitCell}
and \texttt{Topology}, and various properties. The \texttt{UnitCell} class
describes the unit cell of the simulation, and provides calculation of distances
that accounts for periodic boundary conditions. The \texttt{Topology} contains
the atoms and connectivity elements of the system: bonds, angles, dihedral
angles and improper dihedral angles; but also residues. \texttt{Atoms} store
basic data associated with each atom: its name and type as character strings,
its mass and charge as floating point values. For some formats, the atomic name
and type are different: the atomic type will identify an atom or an extended
particle ("He", "Ow", "CH4"); while the atomic name might be an unique
identifier of this specific atom ("C\_a1", "Ow22"). \texttt{Residue} stores
additional atomic grouping, such as molecules, amino- or nucleic-acids, \etc

The \texttt{Property} class can be associated with either a frame, an atom or a
residue. It stores additional metadata that only occurs in some specific
formats, such as atomic hybridization state, molecule name or chain identifier
in bio-molecules. Finally, the \texttt{Selection} class implements chemfiles's
atomic selection language, which can be used to get a list of atoms matching
some constrains, such as \emph{"name == O and x < 22"} or \mbox{\emph{"pairs:
name(\#1) O and name(\#2) F and is\_bonded(\#1, name C)"}}. I will describe this
functionality with more details in section~\ref{sec:chemfiles:selections}.

\subsection{Files and formats}
\label{sec:chemfiles:formats}

As mentioned above, chemfiles' trajectory does read or write frames by itself.
Instead, it uses a subclass of the \texttt{Format} pure virtual abstract base
class. Each supported format is a specialization of this base class,
implementing at least one of three operations: read the next step of the
trajectory, read an arbitrary step of the trajectory, or write a single frame to
the trajectory. Implemented formats as of the 0.9 version of chemfiles are
listed in table~\ref{tab:chemfiles:formats}.

\begin{table}[ht]
    \centering
    \caption{List of format supported by chemfiles as of the 0.9 release, with
    associated file extension, classification as text or binary format and
    read or write support.}
    \label{tab:chemfiles:formats}
    \def\nope{\textcolor{red}{✗}}
    \def\yep{\textcolor{webgreen}{✓}}
    \begin{tabular}{l l c c c}
        \toprule
        Format                         & extension & text based & can read & can write \\
        \midrule
        Amber NetCDF\cite{AmberNetCDF} & .nc       & \nope      &  \yep    & \yep   \\
        CSSR                           & .cssr     & \yep       &  \yep    & \yep   \\
        DCD                            & .dcd      & \nope      &  \yep    & \nope  \\
        GRO                            & .gro      & \yep       &  \yep    & \yep   \\
        LAMMPS Data                    &           & \yep       &  \yep    & \yep   \\
        LAMMPS                         &.lammpstrj & \yep       &  \yep    & \nope  \\
        mmCIF\cite{Bourne1997}         & .mmcif    & \yep       &  \yep    & \yep   \\
        MMTF\cite{Bradley2017}         & .mmtf     & \nope      &  \yep    & \yep   \\
        MOL2                           & .mol2     & \yep       &  \yep    & \yep   \\
        Molden                         & .molen    & \yep       &  \yep    & \nope  \\
        PDB\cite{Berman2003}           & .pdb      & \yep       &  \yep    & \yep   \\
        SDF                            & .sdf      & \yep       &  \yep    & \yep   \\
        TNG\cite{Lundborg2013}         & .tng      & \nope      &  \yep    & \nope  \\
        TRJ                            & .trj      & \nope      &  \yep    & \nope  \\
        TRR                            & .trr      & \nope      &  \yep    & \nope  \\
        Tinker                         & .arc      & \yep       &  \yep    & \yep   \\
        XTC                            & .xtc      & \nope      &  \yep    &\nope   \\
        XYZ                            & .xyz      & \yep       &  \yep    & \yep   \\
        \bottomrule
    \end{tabular}
\end{table}

There are two main types of formats: text based formats store data in a text
file, which must be parsed to extract the data. Some notable examples of
text-based formats include the XYZ, PDB and CIF formats. In all text formats,
floating point data such as positions will be stored as the list of characters
representing their digits in base 10, which must be parsed to reconstruct the
data.

The other class of formats are binary formats, including Amber NetCDF,
GROMACS TNG or XTC. In these formats, data is directly stored as a set of bytes
in the file, which can directly be interpreted as the corresponding floating
point type without additional transformations (except for managing the order in
which bits are written inside a byte, also called \emph{endianess}). Using a
binary format allows to use less space to store the same data: for example the
number 1.23456789 requires 10 bytes when represented as text using UTF-8
encoding, and only 4 as single precision IEEE-754 floating point number. Some
formats such as XTC uses additional molecular simulation specific encoding (such
as reduced decimal precision up to \SI{e-3}{\AA}) to reduce storage size even
further. This is particularly important for long simulations of large systems,
where the trajectory size can easily grow to multiple hundreds of gigabytes. All
these features combine to make binary formats more space- and time-efficient
than text based formats: I found Amber NetCDF trajectories to take roughly five
time less space than the corresponding XYZ file, and be five times faster to
read.

Most binary formats comes with a C or \cxx software library that should be used
to read or write them, or use another generic binary format with molecular
simualtions specific conventions. This is the case of Amber NetCDF, using the
NetCDF format\cite{AmberNetCDF}, MMTF using the MessagePack
format\cite{Bradley2017}, or H5MD using HDF5 data storage\cite{DeBuyl2014}.
This is their main shortcoming when compared to text-based formats, which does
not require special software to create or edit a file.

In chemfiles, the file being read or written is managed by a subclass of either
the \texttt{TextFile} or \texttt{BinaryFile} classes. \texttt{BinaryFile} mainly
provide \cxx style memory management with constructors and destructors on the
top of the format library data structures. Text-based formats uses
\texttt{TextFile} which works slightly differently: the base class defines an
interface (based on \cxx streams), which is then implemented by multiple child
classes. The formats can use any implementation to get access to the data. In
addition to the obvious basic file reader, chemfiles uses this to transparently
read and write compressed files with either the gzip (.gz files) or lzma (.xz
files) compression algorithms. All text-based format thus directly support
reading and writing compressed files without any specific code inside the format
class. In the future, this functionality could be expanded to transparently use
memory-mapped input/output which can be faster for some files; and to download
remote files from Internet.

\subsection{Storing additional data: properties}

Most formats store the same basic subset of data from a molecular simulation:
positions, velocities, atomic names and connectivity. But they also store
additional data or metadata, which are specific to one or few file format. Being
able to read, store and possibly write back this data is important for two
reasons: it increases the amount of data that can be converted from one format
to another through chemfiles, assuming both format support storing it. Secondly,
it allows users of chemfiles working with a specific format to still access all
the data defined in the format.

\TODO: adding new static attributes / data member is not tractable: waste of
space and increase in complexity

Chemfiles solution is to introduce a dynamically typed property, associated with
a name, which can be attached to frames, atoms or residues. The
\texttt{Property} class is a tagged union, containing a type tag which can
change at run-time and the associated data. It can contain either a character
string, a Boolean value (\emph{true} or \emph{false}), a number stored a double
precision IEEE-754 floating point or a three-dimensional vector as three double
precision floating point numbers. These four types cover the vast majority of
data found in molecular simulation: for example atomic forces can be stored as
three-dimensional vector atomic properties; and the user who created a
particular file can be stored as character string associated with the frame.

\TODO Introduces a small penalty at run-time, as the code must check if a
property exists, and if it has the right type.


% \subsection{Atomic selection language}
% \label{sec:chemfiles:selections}
%
% \subsubsection{Multi-atoms selections}
%
% \subsubsection{Implementation strategy}
%
% Lexing => parsing with recursive descent (add grammar?) => create AST
%
% => Evaluate AST, candidate match by candidate match
%
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.6\textwidth]{figures/images/chemfiles-selection-ast}
%     \caption{Abstract syntax tree for the \emph{"name O and (x + y < 7 or index
%     < 80)"} selection. Nodes in green return a Boolean value, nodes in red a
%     character string and nodes in blue deal with numbers.}
%     \label{fig:chemfiles:selection-ast}
% \end{figure}
%
% \subsection{Using a library from multiple programming languages}
%
% \section{cfiles: analysis of trajectories}
%
% \subsection{Algorithm for fast auto-correlations}
%
% \subsection{Elastic constants from fluctuations}

\OnlyInSubfile{\printglobalbibliography}

\end{document}
